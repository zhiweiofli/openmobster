<?xml version="1.0" encoding="UTF-8"?>
<chapter id="mobletmvc">
   <chapterinfo>
      <author>
         <firstname>openmobster</firstname>
         <surname>at gmail.com</surname>
         <email>openmobster@gmail.com</email>
      </author>
   </chapterinfo>
   <title>Moblet MVC Framework</title>
   <sect1>
   		<para>
   		This is a thick client MVC (Model-View-Controller) framework. It is based on a 
<ulink url="http://en.wikipedia.org/wiki/Rich_Internet_application">Rich Internet Application</ulink> design principle.
At this moment in the evolution of the mobile space, there isn't a commonly adopted GUI development standard across various
mobile platforms. This results in a lot of App porting activity across platforms. Although this framework
is not designed for (Write Once, Run Anywhere) approach, it abstracts out a lot of the UI Framework plumbing that would otherwise
need to be written, ported and maintained by the developer. The framework abstracts out some of the low level services into the container
such as App bootstrapping, screen navigation, graceful error handling, and internationalization. 
   		</para>
   		<para>
   		The MVC Framework provides the following features/benefit to an App developer:
   		<itemizedlist>
   			<listitem>An abstraction from the different bootstrapping behavior associated with each native phone platform.</listitem>
   			<listitem>A Command framework used for Event Handling. Abstracts platform-level details related to Event Dispatch Thread, background processing, etc.</listitem>
   			<listitem>A Navigation framework used to help with screen navigation needs.</listitem>
   			<listitem>A portable way to do "Internationalization".</listitem>
   			<listitem>A context oriented "State Management" system used to handle View level state.</listitem>
   		</itemizedlist>
   		</para>
   		<sect2>
   			<title>Components</title>
   			<sect3>
   				<title>Screen</title>
   				<para>
   				<emphasis>Screen</emphasis> is an abstraction for an instance of the App screen that must be made visible to the user at a particular moment in time.
           	  	The low level <emphasis>Navigation</emphasis> service keeps track of the various screens of an App and provides services such as navigating to a specified screen, 
           	  	going back to the previous screen, and going to the home screen. Besides the actual implementation of a "Screen" all services
           	  	related to a "Screen" are portable across mobile platforms
           	  	<programlisting><![CDATA[
public abstract class Screen 
{
	private String id;
	
	public String getId()
	{
		return this.id;
	}
	
	void setId(String id)
	{
		this.id = id;
	}
	
	public abstract void render();	
	public abstract Object getContentPane();			
}
           	  	]]></programlisting>
   				</para>
   			</sect3>
   			<sect3>
   				<title>Command</title>
   				<para>
   				<emphasis>Command</emphasis> is an abstraction for an instance of a GUI Event Handler which receives various callbacks based on the screen's lifecycle.
             	A command typically puts a business process into motion via accessing various other services like the Moblet Data Framework components,
             	and/or native platform services. Command instances are managed by the built-in <emphasis>EventBus</emphasis> of the MVC framework. A 
             	Command has the following life cycle which is managed by the event bus.
             	<itemizedlist>
             		<listitem><emphasis role="bold">doAction:</emphasis> This method is invoked when the actual business logic associated with the command should be executed.</listitem>
             		<listitem><emphasis role="bold">doViewBefore:</emphasis> This method is invoked prior to doAction. 
             		Its executed within an active Event Dispatch Thread and allows making any visual GUI changes to the screen.
             		Some examples would be putting up a simple alert dialog, may be draw a status bar, etc
             		</listitem>
             		<listitem><emphasis role="bold">doViewAfter:</emphasis> This method is invoked after doAction is executed. This is also executed within the context of an Event Dispatch Thread, and allows
             		for making visual GUI changes to the screen.
             		</listitem>
             		<listitem>
             			<emphasis role="bold">doViewError:</emphasis> This method is invoked if an App-level exception is encountered during the execution of this command. Being
             			executed within the context of an Event Dispatch thread, it provides the opportunity to make appropriate GUI changes
             			to robustly handle the error condition.
             		</listitem>
             	</itemizedlist>
   				</para>
   				<para>
   				The MVC Framework provides two builtin Commands. It provides standard behavior associated with these
   				commands. This frees the App Developer to focus on the App behavior.
   				</para>
   				<sect4>
   					<title>LocalCommand</title>
   					<para>
   					This tells the system that the business logic executes quickly and will not freeze the UI. 
   					In the next iteration of the system, this component will probably be renamed to: FastCommand
   					</para>
   					<para>
   					<programlisting><![CDATA[
import net.rim.device.api.ui.component.Status;
import org.openmobster.core.mobileCloud.api.ui.framework.Services;
import org.openmobster.core.mobileCloud.api.ui.framework.command.AppException;
import org.openmobster.core.mobileCloud.api.ui.framework.command.CommandContext;
import org.openmobster.core.mobileCloud.api.ui.framework.command.LocalCommand;

public final class DemoLocalCommand implements LocalCommand
{
	public void doViewBefore(CommandContext commandContext)
	{
		Status.show("LocalCommand about to execute........");		
	}

	public void doAction(CommandContext commandContext) 
	{
		try
		{
			System.out.println("-------------------------------------------------------");
			System.out.println("Demo Local Command successfully executed...............");
			System.out.println("-------------------------------------------------------");
		}
		catch(Exception e)
		{
			throw new RuntimeException(e.toString());
		}
	}	
	
	public void doViewAfter(CommandContext commandContext)
	{
		Services.getInstance().getNavigationContext().navigate("local");
	}
	
	public void doViewError(CommandContext commandContext)
	{
		Status.show("DemoLocalCommand had an error!!");
	}
}
   					]]></programlisting>
   					</para>
   				</sect4>
   				<sect4>
   					<title>RemoteCommand</title>
   					<para>
   					This tells the system that the associated business logic executes slowly and must execute in the background.
   					Usually a RemoteCommand is used when making network calls for data located in the cloud, or may be other scenarios
   					where there is some form of waiting involved. The system wants to provide the appropriate user experience/feedback
   					so that the user does not think the device is frozen. It will put up appropriate status indicators to keep the
   					UI fluid. In the next iteration of the system, this component will probably be renamed to: BusyCommand
   					</para>
   					<programlisting><![CDATA[
import net.rim.device.api.ui.component.Status;
import org.openmobster.core.mobileCloud.api.ui.framework.command.CommandContext;
import org.openmobster.core.mobileCloud.api.ui.framework.command.RemoteCommand;
import org.openmobster.core.mobileCloud.api.ui.framework.navigation.NavigationContext;
import org.openmobster.core.mobileCloud.api.ui.framework.Services;
import org.openmobster.core.mobileCloud.api.service.Request;
import org.openmobster.core.mobileCloud.api.service.Response;
import org.openmobster.core.mobileCloud.api.service.MobileService;

public final class DemoMobileRPC implements RemoteCommand
{
	public void doViewBefore(CommandContext commandContext)
	{	
		//Nothing visual to do before action execution	
	}

	public void doAction(CommandContext commandContext) 
	{
		try
		{
			Request request = new Request("/demo/mobile-rpc");	
			request.setAttribute("param1", "paramValue1");
			request.setAttribute("param2", "paramValue2");
			Response response = new MobileService().invoke(request);
			
			NavigationContext navigation = Services.getInstance().getNavigationContext();
			navigation.setAttribute("home", "param1", response.getAttribute("param1"));
			navigation.setAttribute("home", "param2", response.getAttribute("param2"));
		}
		catch(Exception e)
		{
			throw new RuntimeException(e.toString());
		}
	}	
	
	public void doViewAfter(CommandContext commandContext)
	{
		//Navigate back to home
		NavigationContext navigation = Services.getInstance().getNavigationContext();
		navigation.home();
	}
	
	public void doViewError(CommandContext commandContext)
	{
		//Show an Error status to the user
		Status.show(this.getClass().getName()+" had an error!!");
	}
}
   					]]></programlisting>
   					<para>
   					</para>
   				</sect4>
   			</sect3>
   		</sect2>
   		<sect2>
   			<title>Services</title>
   			<sect3>
   				<title>EventBus</title>
   				<para>
   				The <emphasis role="bold">EventBus</emphasis> shields the App Developer from learning the low-level GUI Event Management details. Each mobile platform
   				has its own methodology for handling GUI events. Typically this revolves around using the Event Dispatch Thread most
   				efficiently and providing a fluid user experience. Users are far more sensitive to GUI pauses on a mobile device
   				compared to their traditional desktop. The <emphasis role="bold">EventBus</emphasis> frees up the App Developer to develop high-level App specific
   				components like Screen and Commands, and lets the EventBus worry about the low-level details.
   				</para>
   			</sect3>
   			<sect3>
   				<title>Navigation</title>
   				<para>
   				The <emphasis role="bold">Navigation</emphasis> service abstracts low-level details about navigating through the
   				various App screens that will be presented to the user.
   				</para>
   			</sect3>
   			<sect3>
   				<title>Internationalization</title>
   				<para>
   				The <emphasis role="bold">Internationalization</emphasis> service abstracts low-level details about localizing an App.
   				It provides a platform independent way to package the resource bundles, and a standard API to access the information.
   				The API is <emphasis>language-portable</emphasis>.
   				</para>
   			</sect3>
   		</sect2>
   		<sect2>
   			<title>Tutorial</title>
   			<sect3>
   				<title>Simple Home Screen</title>
   				<para>
   				Create a simple Home Screen component. This will be the first screen that will be displayed upon launching an App.
   				</para>
   				<programlisting><![CDATA[
import java.util.Vector;

import net.rim.device.api.system.Display;
import net.rim.device.api.ui.Graphics;
import net.rim.device.api.ui.MenuItem;
import net.rim.device.api.ui.container.MainScreen;
import net.rim.device.api.ui.component.Dialog;
import net.rim.device.api.ui.component.ListField;
import net.rim.device.api.ui.component.ListFieldCallback;

import org.openmobster.core.mobileCloud.rimos.configuration.Configuration;
import org.openmobster.core.mobileCloud.api.ui.framework.navigation.Screen;
import org.openmobster.core.mobileCloud.api.ui.framework.Services;
import org.openmobster.core.mobileCloud.api.ui.framework.resources.AppResources;
import org.openmobster.core.mobileCloud.api.model.MobileBean;
import org.openmobster.core.mobileCloud.api.ui.framework.command.CommandContext;

public class HomeScreen extends Screen
{		
	private MainScreen screen;
	private ListField listField;
	private Vector actions;
	private boolean beansDisplayed = false;
	
	public HomeScreen()
	{
		this.screen = new MainScreen();										
	}
	
	public void render()
	{	
		AppResources res = Services.getInstance().getResources();
		Configuration configuration = Configuration.getInstance();
		
		this.screen.setTitle(res.localize("title", "title"));
		
		if(!configuration.isActive())
		{
			Dialog.alert(res.localize("inactive_message","inactive_message"));
			return;
		}
		
		if(!MobileBean.isBooted("/offlineapp/demochannel"))
		{
			Dialog.alert(res.localize("channel_not_ready", "channel_not_ready"));
			return;
		}
		
		if(!this.beansDisplayed)
		{
			MobileBean[] demoBeans = MobileBean.readAll("/offlineapp/demochannel");	
			actions = new Vector();
			int size = demoBeans.length;
			for(int i=0; i<size; i++)
			{
				if(!demoBeans[i].isProxy())
				{
					actions.addElement(demoBeans[i].getValue("demoString"));
				}
				else
				{
					actions.addElement(demoBeans[i].getId()+": proxyState");
				}
			}
			
			this.listField = new ListField(actions.size());
			this.listField.setCallback(new ListFieldCallbackImpl(actions));
			this.screen.add(this.listField);
			this.setMenuItems();
			this.beansDisplayed = true;
		}
	}
	
	public Object getContentPane() 
	{		
		return this.screen;
	}	
	
	private void setMenuItems()
	{
		MenuItem detailItem = new MenuItem("Details", 1, 1){
			public void run()
			{
				//UserInteraction/Event Processing...this is where the Commands can be executed
				HomeScreen.this.handleDetails();
			}
		}; 
										
		this.screen.addMenuItem(detailItem);	
	}
	
	private void handleDetails()
	{
		int selectedIndex = this.listField.getSelectedIndex();
		String selectedBean = (String)this.actions.elementAt(selectedIndex);
		
		//Starting a Command Execution
		CommandContext commandContext = new CommandContext();
		commandContext.setTarget("/demo/details");
		commandContext.setAttribute("selectedBean", selectedBean);
		Services.getInstance().getCommandService().execute(commandContext);
	}
	
	private static class ListFieldCallbackImpl implements ListFieldCallback
	{
		private Vector actions = new Vector();
		
		private ListFieldCallbackImpl(Vector actions)
		{
			this.actions = actions;
		}

		public void drawListRow(ListField listField, Graphics graphics, int index,
		int y, int width) 
		{
			String action = (String)this.actions.elementAt(index);									
			graphics.drawText(action, 0, y);
		}
		
		public Object get(ListField listField, int index) 
		{			
			return this.actions.elementAt(index);
		}

		public int getPreferredWidth(ListField listField) 
		{			
			return Display.getWidth();
		}

		public int indexOfList(ListField listField, String prefix, int start) 
		{			
			return this.actions.indexOf(prefix, start);
		}		
	}		
}
   					]]></programlisting>
   				<para>
   				</para>
   			</sect3>
   			<sect3>
   				<title>Simple Remote Command</title>
   				<para>
   				Create a Simple Remote Command to integrate with information located in the Cloud.
   				</para>
   				<para>
   				<programlisting><![CDATA[
import java.lang.StringBuffer;

import net.rim.device.api.ui.component.Status;
import net.rim.device.api.ui.component.Dialog;

import org.openmobster.core.mobileCloud.api.ui.framework.command.CommandContext;
import org.openmobster.core.mobileCloud.api.ui.framework.command.RemoteCommand;
import org.openmobster.core.mobileCloud.api.ui.framework.navigation.NavigationContext;
import org.openmobster.core.mobileCloud.api.ui.framework.Services;
import org.openmobster.core.mobileCloud.api.model.MobileBean;
import org.openmobster.core.mobileCloud.rimos.util.GenericAttributeManager;

public final class DemoDetails implements RemoteCommand
{
	public void doViewBefore(CommandContext commandContext)
	{		
	}

	public void doAction(CommandContext commandContext) 
	{
		try
		{
			String channel = "/offlineapp/demochannel";
			String selectedBean = (String)commandContext.getAttribute("selectedBean");
			
			String details = null;
			if(selectedBean.endsWith("proxyState"))
			{
				//Lookup by beanId
				String beanId = selectedBean.substring(0,selectedBean.indexOf(':'));
				MobileBean bean = MobileBean.readById(channel, beanId);
				
				StringBuffer buffer = new StringBuffer();
				
				//Reading a simple property
				buffer.append("DemoString: "+bean.getValue("demoString"));
				
				
				details = buffer.toString();
			}
			else
			{
				//Lookup by state..in this case, that of demoString
				GenericAttributeManager criteria = new GenericAttributeManager();
				criteria.setAttribute("demoString", selectedBean);
				
				MobileBean[] beans = MobileBean.queryByEqualsAll(channel, criteria);
				MobileBean unique = beans[0];
				
				StringBuffer buffer = new StringBuffer();
				buffer.append("DemoString: "+unique.getValue("demoString"));
				details = buffer.toString();
			}
			
			commandContext.setAttribute("details", details);
		}
		catch(Exception e)
		{
			throw new RuntimeException(e.toString());
		}
	}	
	
	public void doViewAfter(CommandContext commandContext)
	{
		Dialog.alert((String)commandContext.getAttribute("details"));
		NavigationContext navigation = Services.getInstance().getNavigationContext();
		navigation.home();
	}
	
	public void doViewError(CommandContext commandContext)
	{
		Status.show(this.getClass().getName()+" had an error!!");
	}
}
   					]]></programlisting>
   				</para>
   			</sect3>
   			<sect3>
   				<title>Configuration</title>
   				<para>
   					The Moblet code is packaged in a simple <emphasis>jar</emphasis> file. The configuration is located at:
   					/moblet-app/moblet-app.xml
   				</para>
   				<para>
   				<programlisting><![CDATA[
<moblet-app>
	<commands>
		<command id="startup">org.openmobster.core.mobileCloud.rim_native.framework.command.MobletBootstrapCommand</command>
		<command id="/demo/details">org.openmobster.core.examples.offline.command.DemoDetails</command>
	</commands>
	
	<screens>	    	     
		<screen id="home">org.openmobster.core.examples.offline.screen.HomeScreen</screen>
	</screens>	
	
	<channels>
		<channel>/offlineapp/demochannel</channel>
	</channels>						
</moblet-app>
   					]]></programlisting>
   				</para>
   			</sect3>
   			<sect3>
   				<title>Putting it all together</title>
   				<para>Detailed Examples located at: src/examples/offline-app/moblet, src/examples/mobile-rpc/moblet, and
   				src/mobileCloud/rimos/native-framework/src/test  
   				</para>
   			</sect3>
   		</sect2>
   </sect1>
</chapter>